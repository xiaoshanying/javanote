内存分配策略,垃圾收集器(G1),GC算法,GC参数,对象存活的判定
1.jvm内存划分 参考链接:https://www.cnblogs.com/lifescolor/p/5481588.html
  (1)运行时数据区 + 执行引擎 + 本地库接口 + 本地方法库
  (2)运行时数据区
     方法区 + 堆 + 虚拟机栈 + 本地方法栈 + 程序计数器
  (3)线程共享区域:堆 + 方法区
     线程私有:pc + 虚拟机栈 + 本地方法栈
  (4)各区域作用
     <1>堆:在jvm启动时创建,目的->存放实例对象,数组。
        分代:新生代 + 老年代
            新生代:
                 Eden空间 + from Survivor + To Survivor
                 回收:复制算法。先将内存分为两个部分,一部分用来放入对象,另一部分暂时不用。
                     当使用的一部分内存要进行垃圾回收的时候,会将不需要回收的对象复制保存在
                     另一个空间中,然后在对使用过的那部分区域进行垃圾回收。效率高,浪费空间。
                     所以一般将新生代分为Eden空间和两个Survivor空间,其大小在hotspot虚拟
                     机中的默认比例为8:1:1,这样新生代采用复制算法进行垃圾回收效率就很高了。
                     具体回收过程是->将Eden区域和From Survivor区域作为对象的存储空间,当要进行
                     垃圾回收的时候先将这两个区域中不需要回收的对象复制保存到To Survivor中,然后
                     在进行垃圾回收。另外,当一个对象在Eden区域和From Survivor区域中存储的时候
                     发现内存不足,这时会进行内存分配担保,就是将此对象直接存入老年代中。
            老年代:
                  回收:标记清除或者标记整理。标记清除->首先标记出来需要GC的对象,标记完成后在进行GC,这种算法
                       效率不高，并且会产生很多内存碎片。
                       标记整理->对需要进行的GC对象进行标记,但是不同的是在标记完成后不是立刻进行GC，而是先
                       将不需要GC的对象移动到一端,然后在边界外再对要回收的对象进行GC。
     <2>对象的分配:
            对象优先分配在Eden区域,大对象会直接进入老年代，长期存活的对象会进入老年代，长期存活是根据新生代中的
            对象年龄阈值来定义的。对象刚分配到新生代的时候年龄为1,每进行一次GC对象的年龄会加1,HotSpot中默认的
            阈值是15,也就是说对象年龄到达15岁的时候会被分配到老年区，这个值是可以通过参数配置的。
     <3>新生代GC又叫做minor GC,老年代GC可以设置内存容量达到百分比的多少的时候进行GC,老年代的GC又叫full GC,
        minor gc时间短,频率高,full gc时间长,频率低。
     <4>方法区:
          又被称为永久区,线程共享，是用来存储已经被JVM加载的类信息,常量,静态变量,即时编译器编译后的代码等数据。方法区
          是堆的一个逻辑部分，很少进行垃圾回收，回收目标主要是针对常量池的回收和对类型的卸载。
     <5>JVM栈:
           线程私有,生命周期和线程相同。jvm栈描述的是java方法执行的内存模型。每个方法在执行的同时会创建一个栈帧,用于存储
           局部变量表,操作数栈,动态链接,方法出口灯信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到
           出栈的过程。
           局部变量表中存放了编译期可知的各种基本数据类型,对象的引用类型。局部变量表中需要的内存空间在编译期间完成分配。
           当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
     <6>本地方法栈:
           本地方法栈和jvm栈非常相似。他们之间的区别不过是jvm栈是为执行java方法服务。本地方法栈是为jvm使用到本地方法
           服务。HotSpot虚拟机中直接把本地方法栈和jvm栈合二为一了。
     <7>程序计数器:
           线程私有。可以看做是当前线程所执行的字节码的行号指示器。在jvm的概念模型里,字节码解释器工作就是通过改变这个计数器
           的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。
           如果线程正在执行的是一个java方法,这个计数器记录的是正在执行的jvm字节码指令的地址。如果正在执行的是本地方法,这个
           计数器的值则为空。
2.垃圾收集器(G1) 参考链接 https://blog.csdn.net/coderlius/article/details/79272773
  (1)G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是引入分区的
     思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。
  (2)串行收集器
     <1>串行收集器组合Serial + Serial Old
     <2>开启选项 -XX:+SerialGC
     <3>client模式下的默认收集器
     <4>单线程stop收集.当内存不足时,串行GC设置停顿标识,待所有线程都进入安全点时,应用线程停止,串行gc开始工作。采用单线程方式回收
        空间并整理内存。单线程也意味着复杂度更低，占用内存更少，但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存
        不高，单核甚至双核cpu的场合。
  (3)并行收集器
     <1>并行收集器组合Parallel Scavenge + Parallel Old
     <2>开启选项 -XX:+UseParallelGC 或 -XX:+UseParallelOldGC(可互相激活)
     <3>并行收集器是以关注吞吐量为目标的垃圾收集器,也是server模式下的默认收集器配置，对吞吐量的关注主要体现在年轻代Parallel Scavenge
        收集器上。
     <4>并行收集器与串行收集器工作模式相似,都是stw方式,只是暂停时并行的进行垃圾回收。年轻代采用复制算法,老年代采用标记整理。在回收的同时
        还会对内存进行压缩。关注吞吐量主要指年轻代的Parallel Scavenge收集器。通过两个目标参数-XX:MaxGCPauseMills和-XX:GCTimeRatio
        调整新生代的空间大小,来降低GC触发的频率。并行收集器适合对吞吐量要求远远高于延迟要求的场景,并且在满足最差延时的情况下，并行收集器将
        提供最佳的吞吐量。
  (4)并发标记清除(CMS)收集器
     <1>CMS收集器组合 ParNew + CMS + Serial Old
     <2>开启选项 -XX:UseConcMarkSweepGC
     <3>CMS是以关注延迟为目标,十分优秀的垃圾收收算法,开启后，年轻代使用stw式的并行收集。老年代回收采用CMS进行垃圾回收，对延迟的关注也主要体现
        在老年代CMS上。
     <4>年轻代ParNew与并行收集器类似,而老年代CMS每个收集周期都要经历->初始标记->并发标记->重新标记->并发清除。其中初始标记以stw方式标记所有的
        跟对象,并发标记同应用线程一起并行,标记出(root对象)的可达路径,在进行垃圾回收前，CMS再以一个STW进行重新标记，标记那些由mutator(线程,指
        引起数据变化的线程,即应用线程）修改而可能错过的可达对象,最后得到的不可达对象将在并发清除阶段进行回收。值得注意的是,初始值和重新标记都已优化为
        多线程执行。CMS非常适合堆的内存大,cpu核数多的服务端应用,也是G1出现之前大型应用的首选收集器。
     <5>CMS缺点
        由于并发进行,CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发
        担保机制，串行老年代收集器将会以stw的方式进行一次gc,从而造成较大停顿时间。
        标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数。
        -XX：CMSFullGCsBeforeCompaction(默认为0,即每次都进行内存整理)来指定多少次CMS收集之后,进行一次压缩的Full GC.
  (5)Garbage First(G1)
     <1>开启选项 -XX:+UseG1GC
     <2>之前的垃圾收集器组合,都有几个共同点:
        年轻代,老年代是独立且连续的内存块
        老年代收集使用单eden,双survivor进行复制算法
        老年代收集必须扫描整个老年代区域
        都是以尽可能少而快地执行GC为设计原则
     <3>G1垃圾收集器也是以关注延迟为目标,服务端应用的垃圾收集器，被HotSpot团队给予取代CMS的使命，也是一个非常具有调优潜力的垃圾收集器。虽然G1也有类似
        CMS的收集动作:初始标记->并发标记->重新标记->清除->转移回收。并且也已一个串行收集器做担保机制，但单纯地以类似前三种的过程描述显得并不是很妥当。
     <4>G1收集器与其他收集器的不同:
        i:G1原则是首先收集尽可能多的垃圾。G1不会等内存耗尽(串行,并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了（启发式算法）。在老年代找出具有高
          收集收益的分区进行收集。(同时G1可以根据用户设置的暂停时间自动调整年轻代,和总堆的大小,暂停目标越短年轻代空间越小,总空间就越大)
       ii:G1采用内存分区的思路,将内存划分为一个个相等大小的内存分区,回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区
          为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)。
      iii:G1虽然也是分代收集器,但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念
          ,或者说每个分区都可能随G1的运行在不同代之间前后切换。
     iiii:G1的收集都是stw的,但年轻代和老年代的收集界限比较模糊，采用了混合收集的方式。每次收集即可能只收集年轻代分区,也可能在收集年轻代的同时，包含老年代分区。
          这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。
  (6)G1的内存模型
