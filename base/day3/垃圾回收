内存分配策略,垃圾收集器(G1),GC算法,GC参数,对象存活的判定
1.jvm内存划分 参考链接:https://www.cnblogs.com/lifescolor/p/5481588.html
  (1)运行时数据区 + 执行引擎 + 本地库接口 + 本地方法库
  (2)运行时数据区
     方法区 + 堆 + 虚拟机栈 + 本地方法栈 + 程序计数器
  (3)线程共享区域:堆 + 方法区
     线程私有:pc + 虚拟机栈 + 本地方法栈
  (4)各区域作用
     <1>堆:在jvm启动时创建,目的->存放实例对象,数组。
        分代:新生代 + 老年代
            新生代:
                 Eden空间 + from Survivor + To Survivor
                 回收:复制算法。先将内存分为两个部分,一部分用来放入对象,另一部分暂时不用。
                     当使用的一部分内存要进行垃圾回收的时候,会将不需要回收的对象复制保存在
                     另一个空间中,然后在对使用过的那部分区域进行垃圾回收。效率高,浪费空间。
                     所以一般将新生代分为Eden空间和两个Survivor空间,其大小在hotspot虚拟
                     机中的默认比例为8:1:1,这样新生代采用复制算法进行垃圾回收效率就很高了。
                     具体回收过程是->将Eden区域和From Survivor区域作为对象的存储空间,当要进行
                     垃圾回收的时候先将这两个区域中不需要回收的对象复制保存到To Survivor中,然后
                     在进行垃圾回收。另外,当一个对象在Eden区域和From Survivor区域中存储的时候
                     发现内存不足,这时会进行内存分配担保,就是将此对象直接存入老年代中。
            老年代:
                  回收:标记清除或者标记整理。标记清除->首先标记出来需要GC的对象,标记完成后在进行GC,这种算法
                       效率不高，并且会产生很多内存碎片。
                       标记整理->对需要进行的GC对象进行标记,但是不同的是在标记完成后不是立刻进行GC，而是先
                       将不需要GC的对象移动到一端,然后在边界外再对要回收的对象进行GC。
     <2>对象的分配:
            对象优先分配在Eden区域,大对象会直接进入老年代，长期存活的对象会进入老年代，长期存活是根据新生代中的
            对象年龄阈值来定义的。对象刚分配到新生代的时候年龄为1,每进行一次GC对象的年龄会加1,HotSpot中默认的
            阈值是15,也就是说对象年龄到达15岁的时候会被分配到老年区，这个值是可以通过参数配置的。
     <3>新生代GC又叫做minor GC,老年代GC可以设置内存容量达到百分比的多少的时候进行GC,老年代的GC又叫full GC,
        minor gc时间短,频率高,full gc时间长,频率低。
     <4>方法区:
          又被称为永久区,线程共享，是用来存储已经被JVM加载的类信息,常量,静态变量,即时编译器编译后的代码等数据。方法区
          是堆的一个逻辑部分，很少进行垃圾回收，回收目标主要是针对常量池的回收和对类型的卸载。
     <5>JVM栈:
           线程私有,生命周期和线程相同。jvm栈描述的是java方法执行的内存模型。每个方法在执行的同时会创建一个栈帧,用于存储
           局部变量表,操作数栈,动态链接,方法出口灯信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到
           出栈的过程。
           局部变量表中存放了编译期可知的各种基本数据类型,对象的引用类型。局部变量表中需要的内存空间在编译期间完成分配。
           当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
     <6>本地方法栈:
           本地方法栈和jvm栈非常相似。他们之间的区别不过是jvm栈是为执行java方法服务。本地方法栈是为jvm使用到本地方法
           服务。HotSpot虚拟机中直接把本地方法栈和jvm栈合二为一了。
     <7>程序计数器:
           线程私有。可以看做是当前线程所执行的字节码的行号指示器。在jvm的概念模型里,字节码解释器工作就是通过改变这个计数器
           的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。
           如果线程正在执行的是一个java方法,这个计数器记录的是正在执行的jvm字节码指令的地址。如果正在执行的是本地方法,这个
           计数器的值则为空。
2.垃圾收集器(G1) 参考链接 https://blog.csdn.net/coderlius/article/details/79272773
  (1)G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是引入分区的
     思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。
  (2)串行收集器
     <1>串行收集器组合Serial + Serial Old
     <2>开启选项 -XX:+SerialGC
     <3>client模式下的默认收集器
     <4>单线程stop收集.当内存不足时,串行GC设置停顿标识,待所有线程都进入安全点时,应用线程停止,串行gc开始工作。采用单线程方式回收
        空间并整理内存。单线程也意味着复杂度更低，占用内存更少，但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存
        不高，单核甚至双核cpu的场合。
  (3)并行收集器
     <1>并行收集器组合Parallel Scavenge + Parallel Old
     <2>开启选项 -XX:+UseParallelGC 或 -XX:+UseParallelOldGC(可互相激活)
     <3>并行收集器是以关注吞吐量为目标的垃圾收集器,也是server模式下的默认收集器配置，对吞吐量的关注主要体现在年轻代Parallel Scavenge
        收集器上。
     <4>并行收集器与串行收集器工作模式相似,都是stw方式,只是暂停时并行的进行垃圾回收。年轻代采用复制算法,老年代采用标记整理。在回收的同时
        还会对内存进行压缩。关注吞吐量主要指年轻代的Parallel Scavenge收集器。通过两个目标参数-XX:MaxGCPauseMills和-XX:GCTimeRatio
        调整新生代的空间大小,来降低GC触发的频率。并行收集器适合对吞吐量要求远远高于延迟要求的场景,并且在满足最差延时的情况下，并行收集器将
        提供最佳的吞吐量。
  (4)并发标记清除(CMS)收集器
     <1>CMS收集器组合 ParNew + CMS + Serial Old
     <2>开启选项 -XX:UseConcMarkSweepGC
     <3>CMS是以关注延迟为目标,十分优秀的垃圾收收算法,开启后，年轻代使用stw式的并行收集。老年代回收采用CMS进行垃圾回收，对延迟的关注也主要体现
        在老年代CMS上。
     <4>年轻代ParNew与并行收集器类似,而老年代CMS每个收集周期都要经历->初始标记->并发标记->重新标记->并发清除。其中初始标记以stw方式标记所有的
        跟对象,并发标记同应用线程一起并行,标记出(root对象)的可达路径,在进行垃圾回收前，CMS再以一个STW进行重新标记，标记那些由mutator(线程,指
        引起数据变化的线程,即应用线程）修改而可能错过的可达对象,最后得到的不可达对象将在并发清除阶段进行回收。值得注意的是,初始值和重新标记都已优化为
        多线程执行。CMS非常适合堆的内存大,cpu核数多的服务端应用,也是G1出现之前大型应用的首选收集器。
     <5>CMS缺点
        由于并发进行,CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发
        担保机制，串行老年代收集器将会以stw的方式进行一次gc,从而造成较大停顿时间。
        标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数。
        -XX：CMSFullGCsBeforeCompaction(默认为0,即每次都进行内存整理)来指定多少次CMS收集之后,进行一次压缩的Full GC.
  (5)Garbage First(G1)
     <1>开启选项 -XX:+UseG1GC
     <2>之前的垃圾收集器组合,都有几个共同点:
        年轻代,老年代是独立且连续的内存块
        老年代收集使用单eden,双survivor进行复制算法
        老年代收集必须扫描整个老年代区域
        都是以尽可能少而快地执行GC为设计原则
     <3>G1垃圾收集器也是以关注延迟为目标,服务端应用的垃圾收集器，被HotSpot团队给予取代CMS的使命，也是一个非常具有调优潜力的垃圾收集器。虽然G1也有类似
        CMS的收集动作:初始标记->并发标记->重新标记->清除->转移回收。并且也已一个串行收集器做担保机制，但单纯地以类似前三种的过程描述显得并不是很妥当。
     <4>G1收集器与其他收集器的不同:
        i:G1原则是首先收集尽可能多的垃圾。G1不会等内存耗尽(串行,并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了（启发式算法）。在老年代找出具有高
          收集收益的分区进行收集。(同时G1可以根据用户设置的暂停时间自动调整年轻代,和总堆的大小,暂停目标越短年轻代空间越小,总空间就越大)
       ii:G1采用内存分区的思路,将内存划分为一个个相等大小的内存分区,回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区
          为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)。
      iii:G1虽然也是分代收集器,但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念
          ,或者说每个分区都可能随G1的运行在不同代之间前后切换。
     iiii:G1的收集都是stw的,但年轻代和老年代的收集界限比较模糊，采用了混合收集的方式。每次收集即可能只收集年轻代分区,也可能在收集年轻代的同时，包含老年代分区。
          这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。
  (6)G1的内存模型
3.GC参数 https://www.cnblogs.com/bianzy/p/6635796.html
        https://www.cnblogs.com/f-zhao/p/6160656.html
4.对象存活的判定 https://www.cnblogs.com/jaycekon/p/Java.html 先判断对象是否还有被引用
  (1)程序计数器,虚拟机栈,本地方法栈线程私有,随线程的创建二诞生,因线程的结束而灭亡。栈中的栈帧随着方法的进入和退出会有条不絮的执行着进栈和出栈。每一个栈帧中分配多少内存，
     基本上是在类结构确认下来的时候就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束，内存自然就跟随着回收了。
  (2)我们讨论的垃圾回收，主要就是关于Java堆中废弃对象的回收。Java堆和方法区中，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，
     我们会在程序运行的时候动态创建对象，这部分内存的分配和回收也是动态的，垃圾收集器所关注的是这部分内存如何进行回收。
  (3)引用计数法
     <1>创建对象的时候,给对象创建一个对象计数器,每当有一个地方引用到这个对象的时候，计数器加1,当引用失效的时候,计数器减1.任何时候计数器为0的对象就是不可能被使用的。
     <2>实现简单,判断效率高。但是很难解决对象之间互相循环引用的问题。
     <3>互相引用的例子:
        public class ReferenceGc {
            public Object instance = null;
            public static void main(String[] args){
                ReferenceGc gcA = new ReferenceGc();
                ReferenceGc gcB = new ReferenceGc();
                gcA.instance=gcB;
                gcB.instance=gcA;
                gcA=null;
                gcB=null;

                System.gc();
            }
        }
  (4)可达性分析法
     <1>gc roots的定义范围:虚拟机栈(栈帧中的本地变量表)引用的对象
                         方法区中类静态属性引用的对象
                         方法区中常量引用的对象
                         本地方法栈中jni引用的对象
  (5)对象在被回收前的自我救赎
     <1>没有引用,不可达的对象也并非是非死不可。还有一个自我救赎的机会。
     <2>对象被宣告死亡要经历两个阶段:
        可达性分析,判断对象是否具有有效的引用。
        判断对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，
        虚拟机将这两种情况视为没有必要执行,就是对象已经没有任何机会完成救赎。
        package com.Shop.Test;

        /**
         * Created by Administrator on 2016/7/25.
         */
        public class FinalizeEscapeGc {
            private static FinalizeEscapeGc SAVE_HOOK = null;
            public void isAlive(){
                System.out.println("yes, i am still alive");
            }

            @Override
            protected  void finalize() throws Throwable{
                super.finalize();
                System.out.println("finalize method executed!");
                FinalizeEscapeGc.SAVE_HOOK = this;
            }

            public static void main(String[] args) throws InterruptedException {
                SAVE_HOOK = new FinalizeEscapeGc();
                SAVE_HOOK = null;
                System.gc();
                Thread.sleep(500);
                if(SAVE_HOOK!= null){
                    SAVE_HOOK.isAlive();
                }else{
                    System.out.println("no ,i am dead ");
                }


                SAVE_HOOK = null;
                System.gc();
                Thread.sleep(500);
                if(SAVE_HOOK!= null){
                    SAVE_HOOK.isAlive();
                }else{
                    System.out.println("no ,i am dead ");
                }
            }
        }
        finalize method executed!
        yes, i am still alive
        no ,i am dead
        我们可以看到，在对象“死亡”之后，并没有马上死亡，我们覆盖了父类的finalized 方法，这时候就会给对象一次救赎的机会，但是也就仅此一次，当对象第二次“死亡”的时候，我们发现，即使是覆盖了finalized方法也没有办法再去拯救这个对象了。
        从上面的例子我们可以很直白的理解这个finalized方法在垃圾回收中起到的作用，那就是一次且仅一次救赎的机会。
  (6)方法区的回收
     <1>实际上方法区是会进行垃圾回收的,但是效率远远比不上堆中的垃圾的回收。
     <2>方法区中，垃圾收集的主要内容分为两部分:废弃常量和无用的类
     <3>废弃常量:
        例子，String str= "abc";这时候abc就已经进入了常量池中，当str改变类值，那么就没有对象引用"abc"这个常量，这时候，"abc"就会被系统清理出常量池。常量池中的其他类、方法、字段的符号引用也是如此。
     <4>无用的类:
        判定一个类是否是无用的类的条件相对苛刻许多。类需要同时满足以下三个条件才能算是“无用的类”:
        i:该类所有的实例都已经被回收,也就是java堆中已经不存在该类的任何实例。
       ii:加载该类的ClassLoader已经被回收。
      iii:该类对象的Java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类。
     <5>一般情况下我们不会对方法区的无用类进行回收，但是在大量使用反射，动态代理、CGLib等ByteCode框架、这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。