内存分配策略,垃圾收集器(G1),GC算法,GC参数,对象存活的判定
1.jvm内存划分 参考链接:https://www.cnblogs.com/lifescolor/p/5481588.html
  (1)运行时数据区 + 执行引擎 + 本地库接口 + 本地方法库
  (2)运行时数据区
     方法区 + 堆 + 虚拟机栈 + 本地方法栈 + 程序计数器
  (3)线程共享区域:堆 + 方法区
     线程私有:pc + 虚拟机栈 + 本地方法栈
  (4)各区域作用
     <1>堆:在jvm启动时创建,目的->存放实例对象,数组。
        分代:新生代 + 老年代
            新生代:
                 Eden空间 + from Survivor + To Survivor
                 回收:复制算法。先将内存分为两个部分,一部分用来放入对象,另一部分暂时不用。
                     当使用的一部分内存要进行垃圾回收的时候,会将不需要回收的对象复制保存在
                     另一个空间中,然后在对使用过的那部分区域进行垃圾回收。效率高,浪费空间。
                     所以一般将新生代分为Eden空间和两个Survivor空间,其大小在hotspot虚拟
                     机中的默认比例为8:1:1,这样新生代采用复制算法进行垃圾回收效率就很高了。
                     具体回收过程是->将Eden区域和From Survivor区域作为对象的存储空间,当要进行
                     垃圾回收的时候先将这两个区域中不需要回收的对象复制保存到To Survivor中,然后
                     在进行垃圾回收。另外,当一个对象在Eden区域和From Survivor区域中存储的时候
                     发现内存不足,这时会进行内存分配担保,就是将此对象直接存入老年代中。
            老年代:
                  回收:标记清除或者标记整理。标记清除->首先标记出来需要GC的对象,标记完成后在进行GC,这种算法
                       效率不高，并且会产生很多内存碎片。
                       标记整理->对需要进行的GC对象进行标记,但是不同的是在标记完成后不是立刻进行GC，而是先
                       将不需要GC的对象移动到一端,然后在边界外再对要回收的对象进行GC。
     <2>对象的分配:
            对象优先分配在Eden区域,大对象会直接进入老年代，长期存活的对象会进入老年代，长期存活是根据新生代中的
            对象年龄阈值来定义的。对象刚分配到新生代的时候年龄为1,每进行一次GC对象的年龄会加1,HotSpot中默认的
            阈值是15,也就是说对象年龄到达15岁的时候会被分配到老年区，这个值是可以通过参数配置的。
     <3>新生代GC又叫做minor GC,老年代GC可以设置内存容量达到百分比的多少的时候进行GC,老年代的GC又叫full GC,
        minor gc时间短,频率高,full gc时间长,频率低。
     <4>方法区:
          又被称为永久区,线程共享，是用来存储已经被JVM加载的类信息,常量,静态变量,即时编译器编译后的代码等数据。方法区
          是堆的一个逻辑部分，很少进行垃圾回收，回收目标主要是针对常量池的回收和对类型的卸载。
     <5>JVM栈:
           线程私有,生命周期和线程相同。jvm栈描述的是java方法执行的内存模型。每个方法在执行的同时会创建一个栈帧,用于存储
           局部变量表,操作数栈,动态链接,方法出口灯信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到
           出栈的过程。
           局部变量表中存放了编译期可知的各种基本数据类型,对象的引用类型。局部变量表中需要的内存空间在编译期间完成分配。
           当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
     <6>本地方法栈:
           本地方法栈和jvm栈非常相似。他们之间的区别不过是jvm栈是为执行java方法服务。本地方法栈是为jvm使用到本地方法
           服务。HotSpot虚拟机中直接把本地方法栈和jvm栈合二为一了。
     <7>程序计数器:
           线程私有。可以看做是当前线程所执行的字节码的行号指示器。在jvm的概念模型里,字节码解释器工作就是通过改变这个计数器
           的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。
           如果线程正在执行的是一个java方法,这个计数器记录的是正在执行的jvm字节码指令的地址。如果正在执行的是本地方法,这个
           计数器的值则为空。