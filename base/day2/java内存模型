内存可见性,重排序,顺序一致性,volatile,锁,final
参考链接:https://blog.csdn.net/suifeng3051/article/details/52611310
1.JAVA内存模型简介
  (1)JMM定义了jvm在计算机内存中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。
     java内存模型定义了多线程之间的共享变量的可见性以及如何在需要的时候对共享变量进行同步。
  (2)并发编程的两个关键问题
     <1>线程之间的通信
     <2>线程之间的同步
  (3)线程之间的通信机制
     <1>共享内存:线程之间共享程序的公共状态,线程之间通过写,读内存中的公共状态来隐士的进行通信,典型的共享内存通信方式
        就是通过共享对象进行通信。
     <2>消息传递:线程之间没有公共状态,线程之间必须通过明确的发送消息来显式进行通信,在java中典型的消息传递方式就是wait(),notify()。
  (4)线程之间的同步
     同步是指程序用于控制不同线程之间操作发生相对顺序的机制。
  (5)java的并发采用的是共享内存模型,JMM决定了一个线程对共享变量的写入何时对另一个线程可见。
  (6)jmm详解
     <1>从抽象角度来看,jmm定义了线程和主内存之间的抽象关系。
     <2>线程之间的共享变量存储在主内存中。
     <3>每个线程都有一个私有的本地内存，本地内存中存储了该线程已读/写共享变量的副本。
2.内存可见性
  (1)什么是可见性?
     一个线程对共享变量的修改,能够及时的被其它线程看到。
  (2)共享变量?
     如果一个变量在多个线程的工作内存中都存在副本,那么这个变量就是这几个线程的共享变量。
  (3)所有的变量存储在主内存中,每个线程都有自己独立的工作内存，里边保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)
  (4)jmm的两条规定
     <1>线程对共享变量的所有操作都必须在自己的工作内存中进行,不能直接从主内存读取。
     <2>不同线程之间无法直接访问其他线程工作内存中的变量,线程间变量的传递需要通过主内存来完成。
  (5)要实现共享变量的可见性,必须保证
     <1>线程修改后的共享变量值能够及时的刷新到主内存中。
     <2>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存。
  (6)synchronized实现可见性
     <1>线程解锁前,必须把共享变量的值刷新到主内存。
     <2>线程加锁时,将清空工作内存中的共享变量的值,从而使用共享变量时需要从主内存重新读取最新的值。
     <3>线程执行互斥代码的过程:获得锁 -> 清空工作内存 -> 从主内存copy变量最新副本到工作内存 -> 执行代码 -> 将更改后的共享变量值刷新到主内存中 -> 释放锁
  (7)volatile可见性(不能保证原子性)
     <1>通过加入内存屏障和禁止重排序优化来实现。
     <2>volatile变量在每次被线程访问时，都强迫从主存中重读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存。
  (8)final也可以保证内存可见。
  (9)synchronized和volatile比较
     <1>volatile不需要枷锁,比sync轻量级，不会阻塞线程
     <2>volatile读相当于加锁,写相当于解锁
     <3>sync既能保证可见性,又能保证原子性。volatile只能保证可见性。
  (9)当程序中有一个long或double类型的变量,而且该变量也没有任何关键字修饰,那么此时对64位的long,double变量的读写就不是原子操作,即可以分解:
     因为java内存模型允许JVM将没有被volatile修饰的64位数据类型的读写操作划分为两次32位的读写操作来进行,就可能导致多线程并发访问该变量时,出现
     只读了一半就被抢走资源进而导致数据异常的问题,解决方法是在long,double类型的变量上加入volatile关键字。
     不过大部分虚拟机已经把long,double类型的变量对其进行一些保护,因此在实际编程中也不需刻意为long,double类型的数据加上volatile关键字。
3.重排序
  (1)在执行程序时为了提高性能,编译器和处理器常常会对指令做重排序。
  (2)重排序会遵守数据的依赖性,编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。
  (3)重排序的三种类型
     <1>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
     <2>指令级并行的重排序。现代处理器采用了指令级并行技术(ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器
        指令的执行顺序。
     <3>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
4.顺序一致性
  (1)一个线程中的所有操作必须按照程序的顺序来执行。
  (2)不管程序是否同步,所有线程都只能看到一个单一的操作的执行顺序。每个操作都必须原子执行且立刻对所有线程可见。


