内存可见性,重排序,顺序一致性,volatile,锁,final
参考链接:https://blog.csdn.net/suifeng3051/article/details/52611310
1.JAVA内存模型简介
  (1)JMM定义了jvm在计算机内存中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。
     java内存模型定义了多线程之间的共享变量的可见性以及如何在需要的时候对共享变量进行同步。
  (2)并发编程的两个关键问题
     <1>线程之间的通信
     <2>线程之间的同步
  (3)线程之间的通信机制
     <1>共享内存:线程之间共享程序的公共状态,线程之间通过写,读内存中的公共状态来隐士的进行通信,典型的共享内存通信方式
        就是通过共享对象进行通信。
     <2>消息传递:线程之间没有公共状态,线程之间必须通过明确的发送消息来显式进行通信,在java中典型的消息传递方式就是wait(),notify()。
  (4)线程之间的同步
     同步是指程序用于控制不同线程之间操作发生相对顺序的机制。
  (5)java的并发采用的是共享内存模型,JMM决定了一个线程对共享变量的写入何时对另一个线程可见。
  (6)jmm详解
     <1>从抽象角度来看,jmm定义了线程和主内存之间的抽象关系。
     <2>线程之间的共享变量存储在主内存中。
     <3>每个线程都有一个私有的本地内存，本地内存中存储了该线程已读/写共享变量的副本。
2.内存可见性
  (1)什么是可见性?
     一个线程对共享变量的修改,能够及时的被其它线程看到。
  (2)共享变量?
     如果一个变量在多个线程的工作内存中都存在副本,那么这个变量就是这几个线程的共享变量。
  (3)所有的变量存储在主内存中,每个线程都有自己独立的工作内存，里边保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)
  (4)jmm的两条规定
     <1>线程对共享变量的所有操作都必须在自己的工作内存中进行,不能直接从主内存读取。
     <2>不同线程之间无法直接访问其他线程工作内存中的变量,线程间变量的传递需要通过主内存来完成。
  (5)要实现共享变量的可见性,必须保证
     <1>线程修改后的共享变量值能够及时的刷新到主内存中。
     <2>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存。
  (6)synchronized实现可见性
     <1>线程解锁前,必须把共享变量的值刷新到主内存。
     <2>线程加锁时,将清空工作内存中的共享变量的值,从而使用共享变量时需要从主内存重新读取最新的值。
     <3>线程执行互斥代码的过程:获得锁 -> 清空工作内存 -> 从主内存copy变量最新副本到工作内存 -> 执行代码 -> 将更改后的共享变量值刷新到主内存中 -> 释放锁
  (7)volatile可见性(不能保证原子性)
     <1>通过加入内存屏障和禁止重排序优化来实现。
     <2>volatile变量在每次被线程访问时，都强迫从主存中重读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存。
  (8)final也可以保证内存可见。
  (9)synchronized和volatile比较
     <1>volatile不需要枷锁,比sync轻量级，不会阻塞线程
     <2>volatile读相当于加锁,写相当于解锁
     <3>sync既能保证可见性,又能保证原子性。volatile只能保证可见性。
  (9)当程序中有一个long或double类型的变量,而且该变量也没有任何关键字修饰,那么此时对64位的long,double变量的读写就不是原子操作,即可以分解:
     因为java内存模型允许JVM将没有被volatile修饰的64位数据类型的读写操作划分为两次32位的读写操作来进行,就可能导致多线程并发访问该变量时,出现
     只读了一半就被抢走资源进而导致数据异常的问题,解决方法是在long,double类型的变量上加入volatile关键字。
     不过大部分虚拟机已经把long,double类型的变量对其进行一些保护,因此在实际编程中也不需刻意为long,double类型的数据加上volatile关键字。
3.重排序
  (1)在执行程序时为了提高性能,编译器和处理器常常会对指令做重排序。
  (2)重排序会遵守数据的依赖性,编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。
  (3)重排序的三种类型
     <1>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
     <2>指令级并行的重排序。现代处理器采用了指令级并行技术(ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器
        指令的执行顺序。
     <3>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
4.顺序一致性
  (1)一个线程中的所有操作必须按照程序的顺序来执行。
  (2)不管程序是否同步,所有线程都只能看到一个单一的操作的执行顺序。每个操作都必须原子执行且立刻对所有线程可见。
5.volatile https://www.cnblogs.com/dolphin0520/p/3920373.html
  (1)cpu运行指令涉及到数据的读取,cpu速度很快,内存读写慢,所以,cpu需要把内存中数据加载到自己的告诉缓存中
     每个cpu有自己的高速缓存。操作完数据在写回内存。
  (2)MESI缓存一致性协议
     核心思想:当CPU写数据时,如果发现操作的变量是共享变量.即在其他cpu中也存在该变量的副本，会发出信号通知其他cpu将该变量的缓存行为置为
     无效状态,因此当其他cpu需要读取这个变量时,发现缓存中缓存该变量的缓存行是无效的,那么他就会重新从内存读取。
  (3)并发中的3个概念
     <1>原子性:一个操作或者多个操作要么全部执行,要么都不执行。
     <2>可见性:多个线程访问一个变量时,一个线程修改了这个变量的值,其它线程能够立即看到修改的值。
     <3>有序性:即程序执行的顺序按照代码的先后顺序执行。（靠指令之间的数据依赖性维持,但是多线程会出现问题）
  (4)volatile禁止重排序,具有可见性。但不具有原子性。
  (5)原理,内存屏障
     “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”
     lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
     <1>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
     <2>它会强制将对缓存的修改操作立即写入主存；
     <3>如果是写操作，它会导致其他CPU中对应的缓存行无效。
  (6)使用场景
     <1>对变量的写操作不依赖当前值
     <2>该变量没有包含在具有其他变量的不变式中
     <3>场景
        状态量标记:
        volatile boolean flag = false;
        while(!flag){
            doSomething();
        }

        public void setFlag(){
            flag = true;
        }

        双重检查
        class Singleton{
            private volatile static Singleton instance = null;

            private Singleton() {

            }

            public static Singleton getInstance() {
                if(instance==null) {
                    synchronized (Singleton.class) {
                        if(instance==null)
                            instance = new Singleton();
                    }
                }
                return instance;
            }
        }
6.锁 https://blog.csdn.net/zqz_zqz/article/details/70233767
  (1)线程阻塞的代价
     java的线程是映射到操作系统原生线程之上的，如果要阻塞或者唤醒一个线程就需要操作系统介入。
     需要在用户态和核心态之间切换,这种切换会消耗大量的系统资源。因为用户态与内核态都有各自专用的
     内存空间，专用的寄存器。用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态
     在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。
     <1>如果线程状态切换是一个高频操作,这将会消耗很多cpu的处理时间。
     <2>如果对于那些需要同步的简单的代码块,获取锁挂起操作消耗的时间比用户代码执行的时间还要长。
  (2)java对象结构 https://blog.csdn.net/zqz_zqz/article/details/70246212
7.final https://blog.csdn.net/CT_forever/article/details/77043852



